Date: 2025-10-26
Topic:

  - link: 
    text: |
      JAXAが新型補給機「HTV-X1」を搭載した「H3」ロケット7号機を打ち上げ

      JAXA＝宇宙航空研究開発機構は日本時間2025年10月26日に「H3」ロケット7号機の打ち上げを実施しました。JAXAは公式ライブ配信にて、搭載されていた新型宇宙ステーション補給機1号機「HTV-X1」の分離確認を発表しています。

      打ち上げに関する情報は以下の通りです。

      打ち上げ情報：H3ロケット7号機
      ロケット：H3ロケット（H3-24W）
      打ち上げ日時：日本時間 2025年10月26日9時00分15秒
      発射場：種子島宇宙センター大型ロケット発射場（日本）
      ペイロード：新型宇宙ステーション補給機1号機「HTV-X1」
      HTV-X1について
      HTV-Xは2020年まで運用されていた宇宙ステーション補給機「HTV（こうのとり）」の後継機として開発された無人補給機で、主にISSへの物資輸送を行います。

      打ち上げ時の質量は約16トン。貨物の搭載能力はHTVが質量4トン・容積49立方mだったのに対し、HTV-Xでは質量5.82トン・容積78立方mと1.5倍ほどに向上しています。

      ISSへの物資補給ミッションにおける係留期間は最長6か月間ですが、HTV-XはISS離脱後も最長1.5年間にわたって単体で飛行が可能。物資補給を終えた後は、技術実証や実験に対応する軌道上実証プラットフォームとしてのミッションを行えるように設計されています。

      HTV-X1では、与圧カーゴに窒素・酸素・水の補給タンク、二酸化炭素除去システム、宇宙食や生鮮食品、消耗品、各種実験機器などを搭載。また船外の曝露カーゴには、ISSの「きぼう」日本実験棟の船外で運用される中型曝露実験アダプタ「i-SEEP」をはじめ、超小型衛星放出システム「H-SSOD」、衛星レーザー測距（SLR）用小型リフレクター「Mt. FUJI」、展開型軽量平面アンテナ「DELIGHT」、次世代宇宙用太陽電池「SDX」を搭載しています。

      日本時間2025年10月26日9時00分15秒に打ち上げられたHTV-X1は、発射14分4秒後にH3ロケット7号機の2段目から分離し、軌道に投入されました。分離後のHTV-X1は安定した姿勢を確立し、2枚の太陽電池パドルの展開に成功しています。また、分離後のH3ロケット2段目は、予定されていた技術実証と制御落下を行ったということです。

      この後のHTV-X1は高度約400kmまで上昇してISSとランデブーを行い、日本時間2025年10月30日0時50分頃に、JAXAの油井亀美也宇宙飛行士が操作するISSのロボットアームでキャッチされる予定です。HTV-X1のISS係留期間は最大6か月間、ISS離脱後の技術実証ミッション期間は約3か月間の予定です。

      【最終更新：2025年10月26日12時45分】打上げ経過記者会見の内容を反映して記事本文を更新しました。

      関連画像・映像
      種子島宇宙センターから打ち上げられた「H3」ロケット7号機。JAXAのライブ配信から（Credit: JAXA）
      【▲ 種子島宇宙センターから打ち上げられた「H3」ロケット7号機。JAXAのライブ配信から（Credit: JAXA）】
      新型宇宙ステーション補給機1号機「HTV-X1」（Credit: JAXA）
      【▲ 新型宇宙ステーション補給機1号機「HTV-X1」（Credit: JAXA）】

      

      文／sorae編集部 速報班　編集／sorae編集部

      関連記事
      JAXAが新型補給機「HTV-X」搭載の「H3」ロケット7号機打ち上げ日時を決定
      JAXA、「H3」ロケット“30形態”の燃焼試験を実施　計画通り終了と発表
      JAXA、H3ロケット5号機打ち上げ　準天頂衛星システム「みちびき」6号機を搭載
      参考文献・出典
      JAXA - 新型宇宙ステーション補給機1号機（HTV-X1）／H3ロケット7号機打上げライブ中継（YouTube）
      スポンサーリンク
      関連リンク
      ロケットラボ、日本企業シンスペクティブの小型SAR衛星7機目を打ち上げ
      ブルーオリジン、「ニューシェパード」で15回目の有人ミッション実施


  - link: 
    text: |
      【振り返り】2025年10月20日AWS大規模障害、何が起こったの？
      AWSと関わるエンジニアになってから、一番濃かった月曜でしたね。
      日本の会社なので、US-EAST-1（バージニア北部）リージョンに重いワークロードを積んでいないとはいえ、サポート起票できず、マネコンもままならない状況は、ある種の「非日常」に感じました。
      （個人的には、Perplexityがダウンしてたのはかなりの痛手だった）

      image.pngこれを見た時、さすがに冷え汗出たな

      今回の件に対して、「AWSって、高可用性じゃなかったの？」と疑問に思う人が結構見かけますね。
      言いたいことすごくわかります。が、どんな大規模サービスでもゼロから築いてきて今の姿になったので、（わりと心臓部に近いところで）レガシーではあるものの、なかなか手が出せないコンポーネントが存在します。個人的な見立では、今回の障害もそれに帰因できるのでしょう。
      ドタバタが落ち着いた今、何が起こったのかを自分なりに理解し、備忘録としてこの記事を残したいと思います。
      ネットワーク関連は最低限の知識しか持っておりませんので、変なことを言ったらご指摘いただければ幸いです。

      何が起こったの？
      障害当日ですでに明らかになったのですが、US-EAST-1リージョンのDynamoDBのエンドポイント解決を担うDNSが急に働かなくなり、空のレコードが返ってしまって、DynamoDBとDynamoDBに依存するサービスがバタバタ倒れていったと一言で片付けます。

      もちろんこれだけじゃ物足りないですね。今回の障害を振り返る公式記事が出ましたので、一緒に読んでいきたいと思います。



      時間軸
      日本時間	状態	
      10/20 15:48	インシデント発生	US-EAST-1リージョンサービスへのアクセスエラーと遅延が著しく上昇
      10/20 17:26	原因特定中	US-EAST-1リージョンのDynamoDBの大量エラー並びに他サービスへの影響が確認された
      10/20 18:01	真因特定	DynamoDBへのDNS解決が原因であると分かり、修復に着手
      10/20 18:27	回復の兆し	回復が見られ、新規リクエストが成功するように
      10/20 19:35	初期解決	バックログ処理が残るが、ほどんとのサービスが復旧完了。EC2インスタンスローンチのエラーがまた確認されている
      10/21 07:53	完全解決	すべてのイッシューが解決された
      真因の特定から早期復旧まで思った以上に早かったですね。つまり、外部からの攻撃よりは、オペレーション上のイシューやシステムの不具合が原因だろうと推測できます。

      DNSの仕組み・なぜ今回はダメになったか
      まず前提として、DynamoDBを含むAWSサービスは、DNSでスケーラビリティを保証しています。裏に隠された膨大な処理キャパシティーをシンプルなエンドポイントでユーザー（社内外）に提供するため、DynamoDBのDNSレコードの更新を扱う内部システムが存在します。このシステムでは、高度な自動化が実装されていて、DNSレコードのアップデートだけでなく、自動復旧やトラブル対応もできて並みの障害じゃ倒れない仕様です。

      DNS自動更新システム
      このシステムは、大きく二つのコンポーネントで構成されています。

      DNS Planner
      ロードバランサーのヘルスとキャパシティー状況を監視し、一定時間おきに新しいDNSプランを生成します
      エンドポイント：パブリックリージョンエンドポイントdynamodb.us-east-1.amazonaws.com以外に、IPv6エンドポイントやアカウント特有のエンドポイントなど、このシステムでDynamoDBの複数エンドポイントを制御している
      DNSプラン：全エンドポイントに、どのロードバランサーにどれくらいのウェイトで繋ぐ設定
      異なるエンドポイント間でリソースの共有をし、耐障害性を高めるように
      DNS Enactor
      定期的に新しいDNSプランの有無を確認し、利用可能なプランを取得してRoute 53に適用する
      三つのAZで完全独立な3台のインスタンスで同じ機能を果たす（ここ大事）
      DNSプランを適用する前に、既存プランと比較して、ちゃんと最新かどうかをチェックすることで適用のゴーサインを出す（ここも大事）
      適用後に、適用されたプランよりある程度古くなったプランを削除（ガチで大事）
      名称未設定ファイル.drawio (1).png

      ここまで来て、ジュニアレベルのアーキテクトでも違和感を覚えるのでしょう。同じDNSプランを三台のインスタンスに送って、チェック・適用の操作を三回もさせるのは、さすがに冗長ではありませんか？定期のプルじゃなくイベント駆動のパターンにし、インスタンスの前面にメッセージキューで制御しないのでしょうか？
      もちろん言い分はあります。公式の見解に自分なりの解釈を加えてみると：

      各自インスタンスを完全切り離すのは、高可用性を確保するためだ。それは一理ある。ロードバランサーでも、メッセージキューでも、フェールオーバー処理には時間がかかるので、あえて制御せず、後のこと知らん！の精神でとりあえずイベントを投げれば、確かに一番手っ取り早いかもしれない。あと、かなり低いレイヤーなシステムなので、依存先は少なければ少ないほどよい
      DNSプラン適用プロセスで、リストア機構（ましてやDynamoDB）を導入したり、ロック機構を作ったりするとかえって複雑性が増し、障害リスクが上昇する。それに、適用プロセスが十分短い時間で完了できる（実際今までできていた）としたら、競合の可能性はかなり低く抑えられる。加えて、Route 53 Transactionで全エンドポイントのレコード更新の原子性を確保すれば、二台のインスタンスが同時に適用操作を行ったとしても、どちらかのプランが適用されるだけの話だ
      こうして見れば、案外悪くないソリューションに見えてきたが、実はリスクが潜んでおります。

      想定中の競合
      名称未設定ファイル.drawio (2).png

      まずは想定通りでいきましょう。上記の図通り、稀に二台のEnactorが同時にDNSプランの適用を行うシーンがあります。既存のプランより新しいプランでトリガーされ、ほぼ同時に適用のゴーサインが出されたら、二台が適用のプロセスに入り、バッティングを起こします。競合が起こったエンドポイントでリトライが発生し、リトライが終了したらプラン適用されます。二回適用されるかもしれませんが、両方新しいプランであり、Transactionで原子性が保証されていますので、冗長ではあるが実害はありません。

      しかし今回起こってしまったのは、「隠れパターン」の競合です。

      「隠れパターン」の競合
      名称未設定ファイル.drawio (3).png

      一番目に狂った歯車ーー上記の通常の競合において短時間で終わるはずのリトライが、異常に長くなってしまいました（ここは、長いリトライが起こったインスタンスをEnactorAに）。そして、その間で新しいプランが複数生成され、EnactorBでどんどん適用されていきました。EnactorAにおけるリトライが終了した時点で、すでに結構古いプランになったが、適用のゴーサインは最初に出たので、この古いプランは無事適用されました。
      ここまで来ても、ただ古いDNSプランが適用されるだけの話ですが、厄介なのは適用後のクリーンアッププロセスです。あいにく、EnactorBのプランがどんどん適用されていたところに、EnactorAの古いプランが上書きしてしまい、それとほぼ同時にEnactorBのクリーンアッププロセスが作動し始めました。そして、上書きの直後にEnactorBのクリーンアッププロセスがEnactorAの古いプラン（現行DNSプラン）を削除すべきと判断し、削除しまいました。結果、Route 53にDynamoDBエンドポイントのDNSレコードがまったく存在しない「真空」 が出来上がってしまいました。

      以上、件の顛末でした。

      直感でもわかると思いますが、やはりなんといってもクリーンアップが怪しいですね。競合が起こってしまい他所のクリーンアッププロセスで既存プランが消滅するのは、想像しやすいパターンです。なので、削除する・しないの判定ロジックは存在するはずです。公式文書によると、「適用したプランより著しく古いプラン」を削除対象とするとありますが、具体的な判定基準は明らかにされていません。最低限、Route 53で利用できるプランが0にならないような制御が入っていれば、あるいは適用ゴーサインの判定を最初だけじゃなく最後にも入れれば、話は別になってたかもしれません。
      外部から偉そうに指示厨するのはよくないので、ここまでにしましょう。ソフトウェアアーキテクチャが数えきれない意思決定で形を成し、その波乱万丈を共にしなかったよそ者にとって、分からないものです。

      影響サービス
      DynamoDB自身は言わずもがな、EC2、NLB、Lambdaなどのコアサービスにも、それぞれ異なる形で影響が波及しました。

      EC2
      EC2はDropletWorkflow Manager (DWFM) というシステムでインスタンスのローンチを管理しています。DWFMは定期的にDynamoDBを通してステータスチェックを行い、EC2インスタンスの状態変更が正しく行われているのかを掌握しています。
      このステータスチェックが出来なくなったところで、既存インスタンスにそこまで影響出なかったが新しいインスタンスをローンチすることが出来なくなりました。

      NLB
      NLBはほとんどEC2インスタンス上で実行されているので、EC2インスタンスの障害に波及された形です。

      Lambda
      Lambdaのファンクションメタデータ取得もDynamoDBにかかっています。EC2と似たように、Lambdaも新規作成や更新ができなくなりました。加えて、SQSなどからくるイベントをポーリングするシステムもDynamoDBを使っていますので、イベント処理の遅延が生じました。

      などなど、聞いたことのあるサービスはほどんと影響されてしまい、前代未聞（？）レベルの障害でしたね。ここで割愛します。

      ポエム
      （これは筆者個人の見解であり、所属組織の公式見解を代表するものではありません）

      我々は、一方通行の道に進んでるかもしれない。が、それはそれで悪くない

      株価に表れたように、今回の件、市場や投資家から意外とポジティブな見方が多かったです。ずっとGCPとAzureにシェア奪われるだの、AI時代に取り残されるだの言われてきたAWSですが、最悪の形でそのとんでもない影響力を示すことになりました。今時のインターネットは、AWSを含む巨大ベンダーなしじゃ回れないことの、最たる例でした。
      こんな時にオンプレ回帰など、古き良き時代を取り戻そうとする論調が出てきますが、あえて言い切りましょうーーそれは難しい。そして、戻ったとしてもそんなにいいことはない

      巨大ベンダーが運用の責任を取ってくれたのは、実に優れた仕組みだと思います。どんな規模の会社でも高い可用性を持つサービスを構築できるし、DR（災害復旧計画）もポチポチするだけで出来てしまいます。
      なにより、責任を薄く広くして社会全体で分担し、個人が気楽になれるという、人間の本性に寄り添うシステムがすでに出来上がっております。ユーザーがSaaS企業と、SaaS企業がAWSと、それぞれの間でSLA/OLAを締結しており、責任をちゃんと転嫁できるスキームになります。その全過程に携わる個人や企業が決められた範疇でしか責任負わなくてよくて、過度なペナルティを課されることもなくなりました。
      仮に自社のサーバーでサービスを展開し、今回くらいやらかしがあったら、特定の企業や個人にとっては今以上笑えない事態になっているはずです。自分らの「責任負うキャパシティー」を過大視だけでは問題の解決に繋がらないし、力弱い企業と個人を不幸にするだけです。

      開発者として、何ができるの？

      もちろん、適切なバックアッププランや高可用性のアーキテクチャ設計など、日ごろからアーキテクト力を高める行動は必要ですが、ぶっちゃけ、究極どうしようもないんじゃないかなと思います。
      マルチクラウドにすればいいじゃん！みたいな意見も出てきますが、そこそこうまくいっているITサービスの利益率をもってでも、インフラコストが二倍、三倍になることは到底許容されません。ベンダーを（AWSの他に）分散したところ、分散先の上流にAWSでなにかしらのサービスをホストている可能性もあります。結局、ピラミッドトップの0.01%くらいの可用性に、大金を積んでもよい企業ってどれくらいあるのでしょうか？
      それだけじゃありません。AWS/GCP/Azure/他巨大ベンダーetc.を選択することは、毎月そこから領収書をもらうだけではないです。そのベンダーを中心に採用、組織つくり、技術スタックを固めないといけないことになります。同時に、他ベンダーに切り替えることが極めて困難になります。結局、CTOたちが頭抱えて悩む案件ばかりです。

      一開発者として、選んだ道を信じて進むしかありませんね。

      （あッ！US-EAST-1じゃなくて積極的にUS-WEST-2を使うのは、今からできることですね）
      
  - link: 
    text: |
      GitHub Copilot コーディング エージェントについて
      GitHub の issue を Copilot に割り当てたり、pull request の作成を Copilot に依頼したりできます。

      この機能を使用できるユーザーについて
      Copilot コーディング エージェント は、GitHub Copilot Pro、GitHub Copilot Pro+、GitHub Copilot Business、GitHub Copilot Enterprise プランで使用できます。 エージェントは、マネージド ユーザー アカウント によって所有されて明示的に無効になっているリポジトリを除き、GitHub に格納されているすべてのリポジトリで使用できます。

      この記事の内容
      Copilot コーディング エージェント の概要
      Copilot コーディング エージェント を使うと、GitHub Copilot はバックグラウンドで独立して動作し、人間の開発者と同じようにタスクを完了できます。

      Copilot で次のことができます。

      バグの修正
      増分型の新機能を実装する
      テストのカバレッジを向上させる
      ドキュメントを更新する
      技術的負債に対処する
      タスクを Copilot に委任するには、次の方法があります。

      Copilot に issue を割り当てる。 「GitHub Copilot に pull request の作成を依頼する」を参照してください。
      GitHub のエージェント パネルまたはページ、GitHub Copilot Chat、MCP がサポートされている任意の IDE やエージェント コーディング ツール、または macOS の Raycast で、pull request を作成するよう Copilot に依頼します。 「GitHub Copilot に pull request の作成を依頼する」を参照してください。
      Copilot は、ユーザーが指定したプロンプトに基づいて、割り当てられたタスクの基になっているのが issue の説明かチャット メッセージかを評価します。 その後、Copilot は必要な変更を行って pull request を開きます。 Copilot は完了するとユーザーにレビューを要求し、ユーザーは pull request のコメントを使って Copilot に反復処理を依頼できます。

      コーディング タスクの作業中、Copilot は、GitHub Actions によって実現される独自の一時的な開発環境にアクセスして、コードの探索、変更の実施、自動的なテストとリンターの実行などを行うことができます。

      従来の AI ワークフローと比べた場合の利点
      Copilot コーディング エージェント を効果的に使うと、IDE の従来の AI アシスタントよりも生産性が向上します。

      IDE で AI アシスタントを使うと、コーディングはローカルで行われます。 個々の開発者は AI アシスタントと同期セッションで協力します。 セッション中に下された決定は追跡されません。また、コミットされない限り、時間の経過と共に失われます。 アシスタントはコードの記述を支援するものですが、開発者には他にも手動の手順が多数あります。具体的には、ブランチの作成、コミット メッセージの記述、変更のプッシュ、PR を開く、PR の説明の記述、レビューの取得、IDE での反復処理など、繰り返しです。 このような手順には時間と労力がかかるため、単純な issue や日常的な issue に対しては負担が見合わない場合があります。

      Copilot コーディング エージェント を使うと、GitHub 上のすべてのコーディングと反復処理は、pull request ワークフローの一部として実行されます。 Copilot を使うと、ブランチの作成、コミット メッセージの作成とプッシュ、PR を開く処理、PR の説明の記述を自動化できます。 開発者は、エージェントをバックグラウンドで使用し、PR レビューを使って Copilot を最終的なソリューションへと導くことができます。 GitHub 上で作業すると、透過性が向上し、すべての手順がコミットで実行され、ログで確認できます。 また、GitHub 上で作業すると、チーム全体にコラボレーションを導入できます。

      Copilot コーディング エージェント とエージェント モードの比較
      Copilot コーディング エージェント は、Visual Studio と Visual Studio Code で使用できる "エージェント モード" 機能とは異なります。 Copilot コーディング エージェント は、GitHub Actions を利用した環境で自律的に機能し、GitHub の issue または GitHub Copilot Chat プロンプトを通じて割り当てられた開発タスクを完了し、結果を含む pull request を作成することができます。 これに対し、Visual Studio と Visual Studio Code のエージェント モードは、GitHub Copilot Edits 機能の一部であり、これにより、Copilot はローカル開発環境で直接自律的な編集を行うことができます。 エージェント モードの詳細については、「IDE で GitHub Copilot に質問する」を参照してください。

      Copilot コーディング エージェント を使用したソフトウェア開発の合理化
      タスクを Copilot に割り当てて、ソフトウェア開発ワークフローの機能を強化できます。

      たとえば、バックログの簡単な issue に Copilot を割り当てることができます。 これにより、それらに費やす時間を減らし、より複雑な作業や興味深い作業、または高度な創造的思考を必要とする作業にかける時間を増やすことができます。 Copilot を使って、コードベースや製品の品質の向上にはなるものの、ユーザーがより緊急な作業に集中している間バックログに残ってしまうことが多い、"必要ではないがあると助かる" issue の作業を行うことができます。

      追加のコーディング リソースとして Copilot を使うと、それを使わなければリソース不足のために実施できない可能性があるタスクを、開始することもできます。 たとえば、コードのリファクタリングやログの追加のための Copilot タスクを委任してから、それを Copilot にすぐに割り当てることができます。

      Copilot はタスクを開始でき、ユーザーはそれを引き取って自分で作業を続けることができます。 ユーザーは、新しいプロジェクトのスキャフォールディングの設定のような初期作業を Copilot に割り当てることで、そうしなければそれらの反復タスクに費やしたであろう自分の時間を空けることができます。

      Copilot コーディング エージェント を使用できるようにする
      タスクを Copilot コーディング エージェント に割り当てるには、これを有効にする必要があります。

      Copilot コーディング エージェント は、GitHub Copilot Pro、GitHub Copilot Pro+、GitHub Copilot Business、GitHub Copilot Enterprise プランで使用できます。

      GitHub Copilot Business または GitHub Copilot Enterprise サブスクライバーがエージェントを使うには、事前に管理者が関連するポリシーを有効にする必要があります。

      リポジトリの所有者は、Copilot コーディング エージェント から一部またはすべてのリポジトリをオプトアウトすることを選択できます。

      詳しくは、「GitHub Copilot コーディング エージェントへのアクセスの管理」をご覧ください。

      Copilot コーディング エージェント の使用コスト
      Copilot コーディング エージェント では、GitHub Actions の分単位の時間と Copilot の Premium リクエストが使われます。

      GitHub Actions と Premium リクエストの月間使用許容量の範囲内で、追加費用なしにコーディング タスクの処理を Copilot に依頼できます。

      詳しくは、「GitHub Copilot licenses」をご覧ください。

      組み込みのセキュリティ保護
      他の AI エージェントと同様に、Copilot コーディング エージェント を有効にする場合、セキュリティは基本的な考慮事項です。 Copilot には強力なセキュリティ保護機能が組み込まれており、ベスト プラクティス ガイダンスに従って補完することができます。

      既存のガバナンスに従う: Organization の設定と Enterprise ポリシーによって可用性が制御されます。 Organization に設定されているセキュリティ ポリシーとプラクティスは、Copilot コーディング エージェント にも適用されます。
      制限された開発環境: Copilot は、ファイアウォールによってインターネット アクセスが制御されるサンドボックス開発環境で動作します。 作業対象として割り当てられているリポジトリに対して読み取り専用アクセス権が付与されています。
      ブランチへの制限付きアクセス: Copilot では、copilot/ で始まるブランチのみを作成してプッシュできます。 作業リポジトリのブランチ保護と必須チェックの対象となります。
      書き込みアクセス許可を持つユーザーにのみ回答する: Copilot は、アクセス レベルが低いユーザーからのフィードバックには回答しません。
      外部コラボレーターとして扱われる: Copilot によって提案されたドラフト pull request は、Actions ワークフローを実行する前に、書き込みアクセス許可を持つユーザーによる承認が必要です。 Copilot は pull request を "レビューの準備完了" としてマークできず、pull request を承認またはマージできません。
      コンプライアンスのために追跡される: Copilot のコミットは、issue を割り当てた開発者、または pull request に変更を要求した開発者によって共同作成され、提案された変更の実行者を把握できます。 Copilot に pull request の作成を依頼した開発者は、その pull request を承認できません。 そのため、承認レビューが必要なリポジトリでは、少なくとも 1 人の独立した開発者が Copilot の作業をレビューするように確保できます。
      詳細については、以下を参照してください:

      「Organization 内での GitHub Copilot コーディング エージェントのパイロット使用」(organization 所有者がセキュリティをさらに強化する方法に関する情報)
      GitHub.com での GitHub Copilot コーディング エージェントの責任ある使用
      GitHub Copilot トラスト センター
      リスクと軽減策
      Copilot コーディング エージェント は、ユーザーのコードにアクセスして変更をリポジトリにプッシュできる自律的なエージェントです。 これには特定のリスクが伴います。 可能な場合は、GitHub によって適切な軽減策が適用されます。

      リスク: Copilot がコードの変更をユーザーのリポジトリにプッシュできる
      このリスクを軽減するため、GitHub は次のことを行います。

      タスクを Copilot に割り当てることができるユーザーを制限します。 リポジトリへの書き込みアクセス権限を持つユーザーのみが、Copilot をトリガーして動作させることができます。 書き込みアクセス権限を持たないユーザーからのコメントは、エージェントに対して示されません。
      Copilot によって使われるアクセス トークンのアクセス許可を制限します。 copilot/ で始まるブランチに対してのみプッシュできます。 Copilot は、main または master ブランチにはプッシュできません。
      Copilot の資格情報を制限します。 Copilot は、単純なプッシュ操作のみを実行できます。 git push や他の Git コマンドを直接実行することはできません。
      GitHub Actions ワークフローの実行を制限します。 Copilot のコードがレビューされて、リポジトリへの書き込みアクセス権限を持つユーザーが [Approve and run workflows] ボタンをクリックするまで、ワークフローはトリガーされません。 「GitHub Copilot によって作成された pull request のレビュー」を参照してください。
      Pull request の作成を Copilot に依頼したユーザーがそれを承認できないようにします。 これにより、"必須の承認" ルールとブランチ保護での望ましい制御が維持されます。 「ルールセットで使用できるルール」を参照してください。
      リスク: Copilot が機密情報にアクセスできる
      Copilot はコードや他の機密情報にアクセスでき、誤って、または悪意のあるユーザー入力のために、それを漏洩する可能性があります。 このリスクを軽減するため、GitHub は次のことを行います。

      インターネットへの Copilot のアクセスを制限します。 「GitHub Copilot コーディング エージェント用のファイアウォールのカスタマイズまたは無効化」を参照してください。
      リスク: プロンプト インジェクションの脆弱性
      ユーザーは、Copilot に割り当てられた issue や、Copilot に残されたコメントに、プロンプト インジェクションの形式で非表示のメッセージを含めることができます。 このリスクを軽減するため、GitHub は次のことを行います。

      ユーザー入力を Copilot に渡す前に非表示の文字をフィルター処理します。 たとえば、issue の HTML コメントや pull request のコメントとして入力されたテキストは、Copilot に渡されません。
      Copilot コーディング エージェント の制限
      Copilot コーディング エージェント には、ソフトウェア開発ワークフローおよび他の機能との互換性に一定の制限があります。

      Copilot のソフトウェア開発ワークフローでの制限
      Copilot は、それが pull request を作成しているのと同じリポジトリでのみ変更を行うことができます。 Copilot は、issue を割り当てられたら、その issue が存在するリポジトリでのみ変更を行うことができます。 さらに、Copilot は、1 つの実行で複数のリポジトリの変更を行うことはできません。
      Copilot は、割り当てられた issue と同じリポジトリ内のコンテキストにのみアクセスできます。 既定では、Copilot MCP サーバーとの統合により、一度に 1 つのリポジトリへのアクセスが Copilot に提供されます。 ただし、ユーザーはさらに広範なアクセスを構成できます。 「モデル コンテキスト プロトコル (MCP) を使用した GitHub Copilot コーディング エージェントの拡張」を参照してください。
      Copilot は、一度に 1 つの pull request しか開けません。 Copilot は、割り当てられた各タスクを処理するために、pull request を厳密に 1 つだけ開きます。
      Copilot は、自分で作成していない既存の pull request の作業を行うことはできません。 Copilot で既存の pull request に関するフィードバックを提供したい場合は、それをレビュー担当者として追加できます。 「GitHub Copilot コード レビューの使用」を参照してください。
      Copilot と他の機能との互換性に関する制限
      Copilot は、そのコミットに署名しません。 "署名済みコミットの必須化" ルールまたはブランチ保護が有効になっている場合、Copilot の pull request をマージするには、コミット履歴を書き換える必要があります。 「ルールセットで使用できるルール」を参照してください。

      Copilot は、セルフホステッド GitHub Actions ランナーでは動作しません。 Copilot は、GitHub Actions で実行されている独自の開発環境にアクセスでき、GitHub ホステッド ランナーを使う必要があります。 「GitHub Copilot コーディング エージェント用の開発環境のカスタマイズ」を参照してください。

      Copilot コーディング エージェント は、マネージド ユーザー アカウント によって所有される個人用リポジトリでは動作しません。 これは、Copilot コーディング エージェント には GitHub ホステッド ランナーが必要ですが、ランナーは マネージド ユーザー アカウント で所有されるリポジトリでは使用できないためです。 「GitHub ホステッド ランナー」を参照してください。

      Copilot では、内容の除外は考慮されません。 内容の除外を使うと、管理者は特定のファイルを無視するように Copilot を構成できます。 Copilot コーディング エージェント の使用時には、Copilot はこれらのファイルを無視せず、それを表示および更新できます。 「GitHub Copilot からのコンテンツの除外」を参照してください。

      Copilot コーディング エージェントは、GitHub でホストされているリポジトリでのみ機能します。 リポジトリが別のコード ホスティング プラットフォームを使用して格納されている場合、Copilot は操作できません。

      Copilot コーディング エージェント によって使われる AI モデルは変更できません。 モデルは GitHub によって決定され、GitHub Copilot Chat に選択されたモデルを継承しません。

      現在、Copilot コーディング エージェント で使われているモデルは Claude Sonnet 4 です。 GitHub はこのモデルを変更する権利を留保します。

      ハンズオン プラクティス
      Copilot コーディング エージェント の実践的な経験を積むには、「Copilot コーディング エージェント でチームを拡張する」スキル演習を試してください。

      参考資料
      「GitHub Copilot コーディング エージェント」のハウツー記事
      GitHub.com での GitHub Copilot コーディング エージェントの責任ある使用